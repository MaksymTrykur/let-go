;
; Copyright (c) 2021 Marcin Gasperowicz <xnooga@gmail.com>
; SPDX-License-Identifier: MIT
;

; let-go core library

(def defn (fn [name args & body] (list 'def name (cons 'fn (cons args body)))))

(set-macro! (var defn))

; this is how we make macros before we can use defmacro

(defn defmacro [name args & body]
  (list 'do (cons 'defn (cons name (cons args body))) (list 'set-macro! (list 'var name))))

(set-macro! (var defmacro))

(defmacro comment [x] nil)

; define let as aliast to let* for now
(defmacro let [& body]
  (cons 'let* body))

; same for loop
(defmacro loop [& body]
  (cons 'loop* body))

(defmacro when [condition & forms]
  (list 'if condition (cons 'do forms) nil))

(defmacro when-not [condition & forms]
  (list 'if condition nil (cons 'do forms)))

(defmacro if-not [condition & forms]
  (list 'if condition (first (next forms)) (first forms)))

(defn empty? [xs] (= 0 (count xs)))

(defn concat-list [a b]
  (if (empty? a)
    b
    (cons (first a) (concat-list (next a) b))))

(def > gt)
(def < lt)

(def >= (fn [a b] (or (= a b) (> a b))))
(def <= (fn [a b] (or (= a b) (< a b))))

(defmacro cond [& forms]
  (when (>= (count forms) 2)
    (list 'if (first forms) (second forms)
          (cons 'cond (next (next forms))))))

(defmacro condp [comparator arg & forms]
  (let [l (count forms)]
    (cond (= l 0) nil
          ;; this is an error
          (= l 1) (first forms)
          :else   (list 'if
                        (list comparator arg (first forms))
                        (second forms)
                        (cons 'condp (cons comparator (cons arg (next (next forms)))))))))

(defmacro case [arg & forms]
  (concat-list (list 'condp '= arg) forms))

(defmacro ns [n & nss]
  (let [cns     (list 'in-ns (list 'quote n))
        imports (cons 'use nss)]
    ; FIXME this is not clojure syntax at all
    (list 'do cns imports)))

; makeshift test helper
(def *test-flag* true)

(defmacro test [name & body]
  (let [bod  (cons 'do body)
        pass (list 'println "  \u001b[32mPASS\u001b[0m" name)
        fail (list 'do
                   (list 'set! 'core/*test-flag* false)
                   (list 'println "  \u001b[31mFAIL\u001b[0m" name))]
    (list 'if bod pass fail)))

(defn identity [x] x)

(defn zero? [x] (= 0 x))
(defn pos? [x] (gt x 0))
(defn neg? [x] (lt x 0))

(defn nil? [x] (= nil x))
(defn true? [x] (= x true))
(defn false? [x] (= x false))

(defmacro not= [& xs] (list 'not (cons '= xs)))

(defn inc [x] (+ x 1))
(defn dec [x] (- x 1))

;; bleh
(defn list? [x] (= (type x) (type '())))
(defn vector? [x] (= (type x) (type [])))
(defn map? [x] (= (type x) (type {})))

(defmacro time [& body]
  (let [then   (gensym "time__")
        val    (gensym)
        now    (list 'core/now)
        report (list 'core/println "Elapsed:" (list '.Sub now then))]
    (list 'let (vector then now val (cons 'do body))
          report
          val)))

(defmacro -> [initial & forms]
  (if (zero? (count forms))
    initial
    (reduce
     (fn [a x]
       (if (list? x)
         (cons (first x) (cons a (next x)))
         (list x a)))
     initial
     forms)))

(defmacro ->> [initial & forms]
  (if (zero? (count forms))
    initial
    (reduce
     (fn [a x]
       (if (list? x)
         (concat-list x (list a))
         (list x a)))
     initial
     forms)))

(defn mapcat [f xs]
  (reduce (fn [a x] (concat-list a x)) '() (map f xs)))

(defn filter [f xs]
  (reduce (fn [a x] (if (f x) (cons x a) a)) '() xs))

(defn take [n coll]
  (when (and coll (> n 0))
    (cons (first coll) (take (dec n) (next coll)))))

(defn drop [n xs]
  (if (> n 0)
    (recur (dec n) (next xs))
    xs))

; FIXME this needs multi arity
(defn partition [n step xs]
  (loop [c xs w []]
    (if (>= (count c) n)
      (recur (drop step c) (conj w (take n c)))
      w)))

(defmacro dotimes
  [bindings & body]
  (let [i (first bindings)
        n (second bindings)]
    `(let [n# ~n]
       (loop [~i 0]
         (when (< ~i n#)
           ~@body
           (recur (inc ~i)))))))

(def destructure nil)

(defn destructure-vector [n v]
  (loop [e v i 0 o []]
    (if (empty? e)
      (destructure o)
      (let [x (first e)]
        (cond
          (= x '&) (recur (drop 2 e) i (conj o (second e) (list 'drop i n)))
          (= x :as) (recur (drop 2 e) i (conj o (second e) n))
          :else (recur (next e) (inc i) (conj o x (list 'get n i))))))))

(defn destructure-map [n m]
  (let [gs (reduce (fn [a x] (conj a (first x) (list 'get n (second x))))
                   []
                   (map identity (dissoc m :keys :as))) ; ugly hax to get away with reducing empty map, fix reduce 
        rs (if (:as m)
             (conj gs (:as m) n)
             gs)]
    (destructure (if (:keys m)
                   (reduce (fn [a x] (conj a x (list 'get n (keyword x)))) rs (:keys m))
                   rs))))

(defn destructure [binds]
  (loop [b binds o []]
    (if (empty? b)
      o
      (let [n (first b) f (second b)]
        (cond
          (vector? n) (let [nn (gensym "vec__")
                            vd (destructure-vector nn n)
                            no (conj o nn f)]
                        (recur (drop 2 b) (reduce conj no vd)))
          (map? n) (let [nn (gensym "map__")
                         md (destructure-map nn n)
                         no (conj o nn f)]
                     (recur (drop 2 b) (reduce conj no md)))
          :else (recur (drop 2 b) (conj o n f)))))))

; redefine let to use destructure
(defmacro let [bindings & body]
  `(let* ~(destructure bindings) ~@body))

#_(defmacro loop [bindings & body]
  (trace
   (let [bs (destructure bindings)]
     (if (> (count bs) (count bindings))
       `(loop* ~bindings (let* ~bs ~@body))
       `(loop* ~bindings ~@body)))))

(defmacro when-let [bind & forms]
  `(let ~bind (if ~(second bind) (do ~@forms) nil)))


