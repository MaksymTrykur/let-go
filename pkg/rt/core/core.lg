;
; Copyright (c) 2021 Marcin Gasperowicz <xnooga@gmail.com>
; SPDX-License-Identifier: MIT
;

; let-go core library

(def fn (fn* [& body] (cons 'fn* body)))
(set-macro! (var fn))

(def defn (fn [name args & body] (list 'def name (cons 'fn (cons args body)))))
(set-macro! (var defn))

(def apply apply*)

(defn defmacro [name args & body]
  (list 'do (cons 'defn (cons name (cons args body))) (list 'set-macro! (list 'var name))))

(set-macro! (var defmacro))

(defmacro comment [x] nil)

; define let as aliast to let* for now
(defmacro let [& body]
  (cons 'let* body))

; same for loop
(defmacro loop [& body]
  (cons 'loop* body))

(defmacro when [condition & forms]
  (list 'if condition (cons 'do forms) nil))

(defmacro when-not [condition & forms]
  (list 'if condition nil (cons 'do forms)))

(defmacro if-not [condition & forms]
  (list 'if condition (first (next forms)) (first forms)))

(defn empty? [xs] (= 0 (count xs)))

(defn concat-list [a b]
  (if (empty? a)
    b
    (cons (first a) (concat-list (next a) b))))

(def > gt)
(def < lt)

(def >= (fn [a b] (or (= a b) (> a b))))
(def <= (fn [a b] (or (= a b) (< a b))))

;; this is wrong :^)
(def rest next)
(def parse-long parse-int)

(defmacro cond [& forms]
  (when (>= (count forms) 2)
    (list 'if (first forms) (second forms)
          (cons 'cond (next (next forms))))))

(defmacro condp [comparator arg & forms]
  (let [l (count forms)]
    (cond (= l 0) nil
          ;; this is an error
          (= l 1) (first forms)
          :else   (list 'if
                        (list comparator arg (first forms))
                        (second forms)
                        (cons 'condp (cons comparator (cons arg (next (next forms)))))))))

(defmacro case [arg & forms]
  (concat-list (list 'condp '= arg) forms))

(defmacro ns [n & nss]
  (let [cns     (list 'in-ns (list 'quote n))]
    ; FIXME this is not clojure syntax at all
    (if (empty? nss)
      cns
      (list 'do cns (cons 'use nss)))))

; makeshift test helper
(def *test-flag* true)

(defmacro test [name & body]
  (let [bod  (cons 'do body)
        pass (list 'println "  \u001b[32mPASS\u001b[0m" name)
        fail (list 'do
                   (list 'set! 'core/*test-flag* false)
                   (list 'println "  \u001b[31mFAIL\u001b[0m" name))]
    (list 'if bod pass fail)))

(defn identity [x] x)

(defn zero? [x] (= 0 x))
(defn pos? [x] (gt x 0))
(defn neg? [x] (lt x 0))

(defmacro not= [& xs] (list 'not (cons '= xs)))

(defn complement [f] (fn [x] (not (f x))))

(defn nil? [x] (= nil x))
(defn some? [x] (not= nil x))
(defn true? [x] (= x true))
(defn false? [x] (= x false))

(defn inc [x] (+ x 1))
(defn dec [x] (- x 1))

;; bleh
(defn list? [x] (= (type x) (type '())))
(defn vector? [x] (= (type x) (type [])))
(defn map? [x] (= (type x) (type {})))
(defn symbol? [x] (= (type x) (type 'x)))
(defn keyword? [x] (= (type x) (type :x)))

(defn empty? [x] (zero? (count x)))

(defn set [coll]
  (reduce conj #{} coll))

(defn concat-vec [a b]
  (if (empty? b)
    a
    (reduce conj a b)))

(defmacro time [& body]
  (let [then   (gensym "time__")
        val    (gensym)
        now    (list 'core/now)
        report (list 'core/println "Elapsed:" (list '.Sub now then))]
    (list 'let (vector then now val (cons 'do body))
          report
          val)))

(defmacro -> [initial & forms]
  (if (zero? (count forms))
    initial
    (reduce
     (fn [a x]
       (if (list? x)
         (cons (first x) (cons a (next x)))
         (list x a)))
     initial
     forms)))

(defmacro ->> [initial & forms]
  (if (zero? (count forms))
    initial
    (reduce
     (fn [a x]
       (if (list? x)
         (concat-list x (list a))
         (list x a)))
     initial
     forms)))


(defn spy [s x] (println s x) x)

(defn mapcat [f xs]
  (reduce (fn [a x] (concat-list a x)) '() (map f xs)))

(defn filter [f xs]
  (if xs 
    (let [x (first xs)
          r (next xs)]
      (if (f x) 
        (cons x (filter f r)) 
        (filter f r)))
    (list)))

(defn take [n coll]
  (when (and coll (> n 0))
    (cons (first coll) (take (dec n) (next coll)))))

(defn drop [n xs]
  (if (> n 0)
    (recur (dec n) (next xs))
    xs))

(defn split-at [n coll]
  [(take n coll) (drop n coll)])

(defn partition 
  ([n xs] (partition n n xs))
  ([n step xs]
   (loop [c xs w []]
     (if (>= (count c) n)
       (recur (drop step c) (conj w (take n c)))
       w))))

(defmacro dotimes
  [bindings & body]
  (let [i (first bindings)
        n (second bindings)]
    `(let [n# ~n]
       (loop [~i 0]
         (when (< ~i n#)
           ~@body
           (recur (inc ~i)))))))

(defmacro declare [& names]
  `(do ~@(map #(list 'def % nil) names)))

(declare destructure*)

(defn destructure-vector [n v]
  (loop [e v i 0 o []]
    (if (empty? e)
      (destructure* o)
      (let [x (first e)]
        (cond
          (= x '&) (recur (drop 2 e) i (conj o (second e) (list 'drop i n)))
          (= x :as) (recur (drop 2 e) i (conj o (second e) n))
          :else (recur (next e) (inc i) (conj o x (list 'get n i))))))))

(defn destructure-map [n m]
  (let [gs (reduce (fn [a x] (conj a (first x) (list 'get n (second x))))
                   []
                   (map identity (dissoc m :keys :as))) ; ugly hax to get away with reducing empty map, fix reduce 
        rs (if (:as m)
             (conj gs (:as m) n)
             gs)]
    (destructure* (if (:keys m)
                    (reduce (fn [a x] (conj a x (list 'get n (keyword x)))) rs (:keys m))
                    rs))))

(defn destructure [binds]
  (loop [b binds o [] ob []]
    (if (empty? b)
      [ob o]
      (let [n (first b) f (second b)]
        (cond
          (vector? n) (let [nn (gensym "vec__")
                            vd (destructure-vector nn n)
                            no (conj ob nn f)]
                        (recur (drop 2 b) (concat-vec o vd) no))
          (map? n) (let [nn (gensym "map__")
                         md (destructure-map nn n)
                         no (conj ob nn f)]
                     (recur (drop 2 b) (concat-vec o md) no))
          :else (recur (drop 2 b) o (conj ob n f)))))))

(defn destructure* [binds]
  (loop [b binds o []]
    (if (empty? b)
      o
      (let [n (first b) f (second b)]
        (cond
          (vector? n) (let [nn (gensym "vec__")
                            vd (destructure-vector nn n)
                            no (conj o nn f)]
                        (recur (drop 2 b) (concat-vec no vd)))
          (map? n) (let [nn (gensym "map__")
                         md (destructure-map nn n)
                         no (conj o nn f)]
                     (recur (drop 2 b) (concat-vec no md)))
          :else (recur (drop 2 b) (conj o n f)))))))

; redefine let to use destructure
(defmacro let [bindings & body]
  `(let* ~(destructure* bindings) ~@body))

(defmacro loop [bindings & body]
  (let [[bs nbs] (destructure bindings)]
    (if (> (count nbs) 0)
      `(loop* ~bs (let* ~nbs ~@body))
      `(loop* ~bindings ~@body))))


(defn fn-expand [bindings body]
  (if (some (complement symbol?) bindings)
    (let [padded (reduce (fn [a x] (conj a x nil)) [] bindings)
          [bs nbs] (destructure padded)
          clean (vec (filter some? bs))]
      `(~clean (let* ~nbs ~@body)))
    `(~bindings ~@body)))

(defmacro fn [& forms]
  (cond 
    (vector? (first forms)) 
    (cons 'fn* (fn-expand (first forms) (next forms)))
    
    (list? (first forms))
    `(fn* ~@(map #(fn-expand (first %) (next %)) forms))
    
    :else
    nil ;; throw here
    ))

(defmacro defn [name & forms]
  `(def ~name (fn ~@forms)))

(defmacro while [test & body]
  `(loop* [] (when ~test ~@body (recur))))

(defmacro go [& forms]
  `(go* (fn* [] ~@forms)))

(defn comp
  ([] identity)
  ([f] f)
  ([f g]
   (fn
     ([] (f (g)))
     ([x] (f (g x)))
     ([x y] (f (g x y)))
     ([x y z] (f (g x y z)))
     ([x y z & args] (f (apply g x y z args)))))
  ([f g & fs]
   (reduce comp (list f g fs))))

(defn spread
  [arglist]
  (cond
    (nil? arglist) nil
    (nil? (next arglist)) (first arglist)
    :else (cons (first arglist) (spread (next arglist)))))

(defn list*
  ([args] args)
  ([a args] (cons a args))
  ([a b args] (cons a (cons b args)))
  ([a b c args] (cons a (cons b (cons c args))))
  ([a b c d & more]
   (cons a (cons b (cons c (cons d (spread more)))))))

(defn apply
  ([f args]
   (apply* f (seq args)))
  ([f x args]
   (apply* f (list* x args)))
  ([f x y args]
   (apply* f (list* x y args)))
  ([f x y z args]
   (apply* f (list* x y z args)))
  ([f a b c d & args]
   (apply* f (cons a (cons b (cons c (cons d (spread args))))))))

(defn comp
  ([] identity)
  ([f] f)
  ([f g]
   (fn
     ([] (f (g)))
     ([x] (f (g x)))
     ([x y] (f (g x y)))
     ([x y z] (f (g x y z)))
     ([x y z & args] (f (apply g x y z args)))))
  ([f g & fs]
   (reduce comp (list f g fs))))

(defn juxt
  ([f]
   (fn
     ([] [(f)])
     ([x] [(f x)])
     ([x y] [(f x y)])
     ([x y z] [(f x y z)])
     ([x y z & args] [(apply f x y z args)])))
  ([f g]
   (fn
     ([] [(f) (g)])
     ([x] [(f x) (g x)])
     ([x y] [(f x y) (g x y)])
     ([x y z] [(f x y z) (g x y z)])
     ([x y z & args] [(apply f x y z args) (apply g x y z args)])))
  ([f g h]
   (fn
     ([] [(f) (g) (h)])
     ([x] [(f x) (g x) (h x)])
     ([x y] [(f x y) (g x y) (h x y)])
     ([x y z] [(f x y z) (g x y z) (h x y z)])
     ([x y z & args] [(apply f x y z args) (apply g x y z args) (apply h x y z args)])))
  ([f g h & fs]
   (let [fs (list* f g h fs)]
     (fn
       ([] (reduce #(conj %1 (%2)) [] fs))
       ([x] (reduce #(conj %1 (%2 x)) [] fs))
       ([x y] (reduce #(conj %1 (%2 x y)) [] fs))
       ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))
       ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))

(defn partial
  ([f] f)
  ([f arg1]
   (fn
     ([] (f arg1))
     ([x] (f arg1 x))
     ([x y] (f arg1 x y))
     ([x y z] (f arg1 x y z))
     ([x y z & args] (apply f arg1 x y z args))))
  ([f arg1 arg2]
   (fn
     ([] (f arg1 arg2))
     ([x] (f arg1 arg2 x))
     ([x y] (f arg1 arg2 x y))
     ([x y z] (f arg1 arg2 x y z))
     ([x y z & args] (apply f arg1 arg2 x y z args))))
  ([f arg1 arg2 arg3]
   (fn
     ([] (f arg1 arg2 arg3))
     ([x] (f arg1 arg2 arg3 x))
     ([x y] (f arg1 arg2 arg3 x y))
     ([x y z] (f arg1 arg2 arg3 x y z))
     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))
  ([f arg1 arg2 arg3 & more]
   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))

(defn reverse [coll]
  (reduce conj () coll))

(defmacro if-let
  ([bindings then]
   `(if-let ~bindings ~then nil))
  ([bindings then else]
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if temp#
          (let [~form temp#]
            ~then)
          ~else)))))

(defmacro when-let
  [bindings & body]
  (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (when temp#
         (let [~form temp#]
           ~@body)))))

(defmacro if-some
  ([bindings then]
   `(if-some ~bindings ~then nil))
  ([bindings then else]
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if (nil? temp#)
          ~else
          (let [~form temp#]
            ~then))))))

(defmacro when-some
  [bindings & body]
  (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (if (nil? temp#)
         nil
         (let [~form temp#]
           ~@body)))))

(defn every?
  [pred coll]
  (cond
    (nil? coll) true
    (pred (first coll)) (recur pred (next coll))
    :else false))

(defn get-in
  ([m ks]
   (reduce get m ks))
  ([m ks not-found]
   (loop [sentinel (gensym)
          m m
          ks ks]
     (if ks
       (let [m (get m (first ks) sentinel)]
         (if (= sentinel m)
           not-found
           (recur sentinel m (next ks))))
       m))))

(defn assoc-in
  [m [k & ks] v]
  (if ks
    (assoc m k (assoc-in (get m k) ks v))
    (assoc m k v)))

(defn update-in
  ([m ks f & args]
   (let [up (fn up [m ks f args]
              (let [[k & ks] ks]
                (if ks
                  (assoc m k (up (get m k) ks f args))
                  (assoc m k (apply f (get m k) args)))))]
     (up m ks f args))))

(defn update
  ([m k f]
   (assoc m k (f (get m k))))
  ([m k f x]
   (assoc m k (f (get m k) x)))
  ([m k f x y]
   (assoc m k (f (get m k) x y)))
  ([m k f x y z]
   (assoc m k (f (get m k) x y z)))
  ([m k f x y z & more]
   (assoc m k (apply f (get m k) x y z more))))

(defn fnil
  ([f x]
   (fn
     ([a] (f (if (nil? a) x a)))
     ([a b] (f (if (nil? a) x a) b))
     ([a b c] (f (if (nil? a) x a) b c))
     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))
  ([f x y]
   (fn
     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))
     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))
     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))
  ([f x y z]
   (fn
     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))
     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))
     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))

;; set difference
(defn difference
  ([s1] s1)
  ([s1 s2]
   (if (< (count s1) (count s2))
     (reduce (fn [result item]
               (if (contains? s2 item)
                 (disj result item)
                 result))
             s1 s1)
     (reduce disj s1 s2)))
  ([s1 s2 & sets]
   (reduce difference s1 (conj sets s2))))

;; set intersection
(defn intersection
  ([s1] s1)
  ([s1 s2]
   (if (< (count s2) (count s1))
     (recur s2 s1)
     (reduce (fn [result item]
               (if (contains? s2 item)
                 result
                 (disj result item)))
             s1 (seq s1)))))